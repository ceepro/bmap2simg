#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A class that Writes an Android Sparse image file (.simg).
"""

import os
import stat
import sys
import hashlib
import logging
import datetime
import struct

# The highest supported bmap format version
SUPPORTED_BMAP_VERSION = "2.0"

# Android Sparse Image definitions
SPARSE_IMG_HDR_MAGIC  = 0xed26ff3a
SPARSE_IMG_HDR_MAJOR  = 1
SPARSE_IMG_HDR_MINOR  = 0
SPARSE_IMG_HDR_SIZE   = 28
SPARSE_CHUNK_HDR_SIZE = 12

SPARSE_CHUNK_RAW  = 0xCAC1
SPARSE_CHUNK_FILL = 0xCAC2
SPARSE_CHUNK_DC   = 0xCAC3

# The default image block size used - 4K is used by bmap
IMAGE_BLOCK_SIZE      = 4096

_log = logging.getLogger(__name__)  # pylint: disable=C0103

class Error(Exception):
    """
    A class for exceptions generated by the 'BmapCopy' module. We currently
    support only one type of exceptions, and we basically throw human-readable
    problem description in case of errors.
    """
    pass

class SimgWriter(object):
    def __init__(self, input_image, output_image):
        
        self._input_f_obj = open(input_image, "rb")
        self._output_f_obj = open(output_image, "wb")
        self._chunks = 0
        self._total_input_blocks = 0

        # Write Android sparse image header to output file:
        img_hdr = self._get_image_header(self._total_input_blocks, self._chunks, 0)
        self._output_f_obj.write(img_hdr)

    def _get_image_header(self, total_blocks, total_chunks, image_checksum):
        img_hdr = struct.pack('IHHHHIIII', 
                              SPARSE_IMG_HDR_MAGIC,     # magic
                              SPARSE_IMG_HDR_MAJOR,     # major_version
                              SPARSE_IMG_HDR_MINOR,     # minor_version
                              SPARSE_IMG_HDR_SIZE,      # file_hdr_sz
                              SPARSE_CHUNK_HDR_SIZE,    # chunk_hdr_sz
                              IMAGE_BLOCK_SIZE,         # blk_sz
                              total_blocks,             # total_blks
                              total_chunks,             # total_chunks
                              image_checksum)           # image_checksum
        return img_hdr

    def _get_chunk_header(self, type, block_cnt, size_bytes):
        chunk_hdr = struct.pack('HHII', 
                                type,                               # chunk_type
                                0,                                  # reserved1
                                block_cnt,                          # chunk_sz (in blocks)
                                size_bytes + SPARSE_CHUNK_HDR_SIZE) # total_sz (in bytes including header)
        return chunk_hdr

    def add_data_chunk(self, offset, length):
        _log.debug("Adding data chunk to output: offset=%d, len=%d" % (offset, length))

        block_cnt = length // IMAGE_BLOCK_SIZE

        # Write data chunk Header to output file:
        chunk_hdr = self._get_chunk_header(SPARSE_CHUNK_RAW, block_cnt, length)
        self._output_f_obj.write(chunk_hdr)

        # Read the raw data chunk from input file and write it to output file:
        self._input_f_obj.seek(offset)
        data = self._input_f_obj.read(length)
        self._output_f_obj.write(data)

        # Increment counters:
        self._total_input_blocks += block_cnt
        self._chunks += 1

    def add_dont_care_chunk(self, length):
        _log.debug("Adding don't care chunk to output: len=%d" % (length))

        block_cnt = length // IMAGE_BLOCK_SIZE

        # Write don't care chunk Header to output file:
        chunk_hdr = self._get_chunk_header(SPARSE_CHUNK_DC, block_cnt, 0)
        self._output_f_obj.write(chunk_hdr)

        # Increment counters:
        self._total_input_blocks += block_cnt
        self._chunks += 1

    def finalize(self):
        self._input_f_obj.close()

        # Update the image header values:
        img_hdr = self._get_image_header(self._total_input_blocks, self._chunks, 0)
        self._output_f_obj.seek(0)
        self._output_f_obj.write(img_hdr)
        self._output_f_obj.close()

    