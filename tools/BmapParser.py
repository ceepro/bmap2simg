#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A class that parses the block map (bmap) xml file.

The bmap file is an XML file which contains a list of mapped blocks of the
image. Mapped blocks are the blocks which have disk sectors associated with
them, as opposed to holes, which are blocks with no associated disk sectors. In
other words, the image is considered to be a sparse file, and bmap basically
contains a list of mapped blocks of this sparse file. The bmap additionally
contains some useful information like block size (usually 4KiB), image size,
mapped blocks count, etc.

"""

import os
import stat
import sys
import hashlib
import logging
import datetime
from xml.etree import ElementTree

# The highest supported bmap format version
SUPPORTED_BMAP_VERSION = "2.0"

class Error(Exception):
    """
    A class for exceptions generated by the 'BmapParser' module. We currently
    support only one type of exceptions, and we basically throw human-readable
    problem description in case of errors.
    """
    pass

class BmapParser(object):
    def __init__(self, bmap):
        self._xml = None
        self._bmap_path = bmap
        self._bmap_f_obj = open(self._bmap_path, "rb")

        self._batch_blocks = None
        self._batch_bytes = 1024 * 1024 # 1 MB batches

        self.bmap_version = None
        self.bmap_version_major = None
        self.bmap_version_minor = None
        self.block_size = None
        self.blocks_cnt = None
        self.mapped_cnt = None
        self.image_size = None
        self.image_size_human = None
        self.mapped_size = None
        self.mapped_size_human = None
        self.mapped_percent = None

        # The bmap file checksum type and length
        self._cs_type = None
        self._cs_len = None
        self._cs_attrib_name = None
        self._bmap_cs_attrib_name = None

        # Parse the bmap XML file:
        self._parse_bmap()

        self._batch_blocks = self._batch_bytes // self.block_size

    def _human_size(self, size):
        """Transform size in bytes into a human-readable form."""
        if size == 1:
            return "1 byte"

        if size < 512:
            return "%d bytes" % size

        for modifier in ["KiB", "MiB", "GiB", "TiB"]:
            size /= 1024.0
            if size < 1024:
                return "%.1f %s" % (size, modifier)

        return "%.1f %s" % (size, 'EiB')

    def _verify_bmap_checksum(self):
        """
        This is a helper function which verifies the bmap file checksum.
        """

        import mmap

        correct_chksum = self._xml.find(self._bmap_cs_attrib_name).text.strip()

        # Before verifying the shecksum, we have to substitute the checksum
        # value stored in the file with all zeroes. For these purposes we
        # create private memory mapping of the bmap file.
        mapped_bmap = mmap.mmap(self._bmap_f_obj.fileno(), 0,
                                access=mmap.ACCESS_COPY)

        chksum_pos = mapped_bmap.find(correct_chksum.encode())
        assert chksum_pos != -1

        mapped_bmap[chksum_pos:chksum_pos + self._cs_len] = b'0' * self._cs_len

        hash_obj = hashlib.new(self._cs_type)
        hash_obj.update(mapped_bmap)
        calculated_chksum = hash_obj.hexdigest()

        mapped_bmap.close()

        if calculated_chksum != correct_chksum:
            raise Error("checksum mismatch for bmap file '%s': calculated "
                        "'%s', should be '%s'"
                        % (self._bmap_path, calculated_chksum, correct_chksum))

    def _parse_bmap(self):
        """
        Parse the bmap file and initialize corresponding class instance attributs.
        """

        try:
            self._xml = ElementTree.parse(self._bmap_f_obj)
        except ElementTree.ParseError as err:
            # Extrace the erroneous line with some context
            self._bmap_f_obj.seek(0)
            xml_extract = ""
            for num, line in enumerate(self._f_bmap):
                if num >= err.position[0] - 4 and num <= err.position[0] + 4:
                    xml_extract += "Line %d: %s" % (num, line)

            raise Error("cannot parse the bmap file '%s' which should be a "
                        "proper XML file: %s, the XML extract:\n%s" %
                        (self._bmap_path, err, xml_extract))

        xml = self._xml
        self.bmap_version = str(xml.getroot().attrib.get('version'))

        # Make sure we support this version
        self.bmap_version_major = int(self.bmap_version.split('.', 1)[0])
        self.bmap_version_minor = int(self.bmap_version.split('.', 1)[1])
        if self.bmap_version_major > int(SUPPORTED_BMAP_VERSION.split('.', 1)[0]):
            raise Error("only bmap format version up to %d is supported, "
                        "version %d is not supported"
                        % (SUPPORTED_BMAP_VERSION, self.bmap_version_major))

        # Fetch interesting data from the bmap XML file
        self.block_size = int(xml.find("BlockSize").text.strip())
        self.blocks_cnt = int(xml.find("BlocksCount").text.strip())
        self.mapped_cnt = int(xml.find("MappedBlocksCount").text.strip())
        self.image_size = int(xml.find("ImageSize").text.strip())
        self.image_size_human = self._human_size(self.image_size)
        self.mapped_size = self.mapped_cnt * self.block_size
        self.mapped_size_human = self._human_size(self.mapped_size)
        self.mapped_percent = (self.mapped_cnt * 100.0) / self.blocks_cnt

        blocks_cnt = (self.image_size + self.block_size - 1) // self.block_size
        if self.blocks_cnt != blocks_cnt:
            raise Error("Inconsistent bmap - image size does not match "
                        "blocks count (%d bytes != %d blocks * %d bytes)"
                        % (self.image_size, self.blocks_cnt, self.block_size))

        if self.bmap_version_major > 1 or \
           (self.bmap_version_major == 1 and self.bmap_version_minor == 4):
            # In bmap format version 1.0-1.3 the only supported checksum type
            # was SHA1. Version 2.0 started supporting arbitrary checksum
            # types. A new "ChecksumType" tag was introduce to specify the
            # checksum function name. And all XML tags which contained "sha1"
            # in their name were renamed to something more neutral. This was an
            # change incompatible with previous formats.
            #
            # There is a special format version 1.4, which should not have been
            # ever issued, but was released by a mistake. The mistake was that
            # when implementing version 2.0 support we mistakenly gave it
            # version number 1.4. This was later on fixed and format version
            # 1.4 became version 2.0. So 1.4 and 2.0 formats are identical.
            #
            # Note, bmap files did not contain checksums prior to version 1.3.
            self._cs_type = xml.find("ChecksumType").text.strip()
            self._cs_attrib_name = "chksum"
            self._bmap_cs_attrib_name = "BmapFileChecksum"
        elif self.bmap_version_minor == 3:
            self._cs_type = "sha1"
            self._cs_attrib_name = "sha1"
            self._bmap_cs_attrib_name = "BmapFileSHA1"

        if self._cs_type:
            try:
                self._cs_len = len(hashlib.new(self._cs_type).hexdigest())
            except ValueError as err:
                raise Error("cannot initialize hash function \"%s\": %s" %
                            (self._cs_type, err))
            self._verify_bmap_checksum()

    def get_block_ranges(self):
        """
        This is a helper generator that parses the bmap XML file and for each
        block range in the XML file it yields ('first', 'last', 'chksum')
        tuples, where:
          * 'first' is the first block of the range;
          * 'last' is the last block of the range;
          * 'chksum' is the checksum of the range ('None' is used if it is
            missing).

        If there is no bmap file, the generator just yields a single range
        for entire image file. If the image size is unknown, the generator
        infinitely yields continuous ranges of size '_batch_blocks'.
        """

        if not self._bmap_f_obj:
            # We do not have the bmap, yield a tuple with all blocks
            if self.blocks_cnt:
                yield (0, self.blocks_cnt - 1, None)
            else:
                # We do not know image size, keep yielding tuples with many
                # blocks infinitely.
                first = 0
                while True:
                    yield (first, first + self._batch_blocks - 1, None)
                    first += self._batch_blocks
            return

        # We have the bmap, just read it and yield block ranges
        xml = self._xml
        xml_bmap = xml.find("BlockMap")

        for xml_element in xml_bmap.findall("Range"):
            blocks_range = xml_element.text.strip()
            # The range of blocks has the "X - Y" format, or it can be just "X"
            # in old bmap format versions. First, split the blocks range string
            # and strip white-spaces.
            split = [x.strip() for x in blocks_range.split('-', 1)]

            first = int(split[0])
            if len(split) > 1:
                last = int(split[1])
                if first > last:
                    raise Error("bad range (first > last): '%s'" % blocks_range)
            else:
                last = first

            if self._cs_attrib_name in xml_element.attrib:
                chksum = xml_element.attrib[self._cs_attrib_name]
            else:
                chksum = None

            yield (first, last, chksum)

    def get_batches(self, first, last):
        """
        This is a helper generator which splits block ranges from the bmap file
        to smaller batches. Indeed, we cannot read and write entire block
        ranges from the image file, because a range can be very large. So we
        perform the I/O in batches. Batch size is defined by the
        '_batch_blocks' attribute. Thus, for each (first, last) block range,
        the generator yields smaller (start, end, length) batch ranges, where:
          * 'start' is the starting batch block number;
          * 'last' is the ending batch block number;
          * 'length' is the batch length in blocks (same as
             'end' - 'start' + 1).
        """

        batch_blocks = self._batch_blocks

        while first + batch_blocks - 1 <= last:
            yield (first, first + batch_blocks - 1, batch_blocks)
            first += batch_blocks

        batch_blocks = last - first + 1
        if batch_blocks:
            yield (first, first + batch_blocks - 1, batch_blocks)

    def get_block_size(self):
        return self.block_size
